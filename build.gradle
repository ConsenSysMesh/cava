import java.util.regex.Pattern

buildscript {
  repositories {
    maven { url 'https://consensys.bintray.com/consensys/' }
    jcenter()
  }
}
plugins {
  id 'com.diffplug.gradle.spotless' version '3.12.0'
  id 'net.ltgt.errorprone' version '0.0.14'
  id 'io.spring.dependency-management' version '1.0.4.RELEASE'
  id 'com.github.hierynomus.license' version '0.14.0'
  id 'com.jfrog.bintray' version '1.8.1'
  id 'org.jetbrains.kotlin.jvm' version '1.2.41'
  id 'org.jetbrains.dokka' version '0.9.17'
}


//////
// Version numbering

def versionNumber = '0.3.0'
def buildVersion = versionNumber + buildTag()

static String buildTag() {
  if (System.getenv('BUILD_RELEASE') == 'true') {
    return ''
  }
  if (System.getenv('CIRCLECI')) {
    def buildNumber = System.getenv('CIRCLE_SHA1').take(4).toUpperCase() +
      String.format('%02X', System.getenv('CIRCLE_BUILD_NUM').toInteger() % 256, 16)
    return '-' + buildNumber + '-snapshot'
  }
  return '-dev'
}


//////
// Default tasks and build aliases

defaultTasks 'checkLicenses', 'spotlessCheck', 'jar', 'test', ':javadoc'

def buildAliases = ['dev': [
    'spotlessApply',
    'checkLicenses',
    ':jar',
    'test',
    ':javadoc'
  ]]

def expandedTaskList = []
gradle.startParameter.taskNames.each {
  expandedTaskList << (buildAliases[it] ? buildAliases[it] : it)
}
gradle.startParameter.taskNames = expandedTaskList.flatten()

//////
// Source formatting

apply plugin: 'com.diffplug.gradle.spotless'
spotless {
  groovyGradle {
    target '**/*.gradle'
    greclipse().configFile(rootProject.file('gradle/greclipse-gradle-consensys-style.properties'))
    endWithNewline()
  }
}

task deploy() {}

allprojects {
  apply plugin: 'java-library'
  apply plugin: 'kotlin'
  apply plugin: 'io.spring.dependency-management'
  apply plugin: 'jacoco'
  apply plugin: 'net.ltgt.errorprone'
  apply plugin: 'com.jfrog.bintray'
  apply plugin: 'maven-publish'
  apply plugin: 'org.jetbrains.dokka'
  apply plugin: 'signing'
  apply from: "${rootDir}/dependency-versions.gradle"
  apply from: "${rootDir}/gradle/check-licenses.gradle"

  version = buildVersion

  repositories { jcenter() }

  //////
  // Use JUnit5 for testing

  test { useJUnitPlatform() { includeEngines 'spek', 'junit-jupiter' } }


  //////
  // Compiler arguments

  dependencies { errorprone 'com.google.errorprone:error_prone_core' }

  tasks.withType(JavaCompile) {
    options.compilerArgs += [
      '-proc:none',
      '-Xlint:unchecked',
      '-Xlint:cast',
      '-Xlint:rawtypes',
      '-Xlint:overloads',
      '-Xlint:divzero',
      '-Xlint:finally',
      '-Xlint:static',
      '-Werror',
      '-Xep:FutureReturnValueIgnored:OFF'
    ]
  }

  tasks.withType(org.jetbrains.kotlin.gradle.tasks.KotlinCompile).all {
    kotlinOptions {
      jvmTarget = "1.8"
      allWarningsAsErrors = true
      freeCompilerArgs = ['-Xjsr305=strict']
    }
  }

  kotlin.experimental.coroutines = 'enable'


  //////
  // Documentation

  dokka {
    outputFormat = 'html'
    outputDirectory = "$buildDir/docs/dokka"
    jdkVersion = 8
    includeNonPublic = false
    def relativePath = rootDir.toPath().relativize(projectDir.toPath()).toString()
    linkMapping {
      dir = projectDir.toString()
      url = "https://github.com/consensys/cava/blob/master/$relativePath"
      suffix = "#L"
    }
  }


  //////
  // Packaging and deployment

  tasks.withType(Jar) {
    if (rootProject == project) {
      baseName = project.name
    } else {
      baseName = rootProject.name + '-' + project.name
    }
    manifest {
      attributes('Implementation-Title': baseName,
      'Implementation-Version': project.version)
    }
  }

  jar {
    destinationDir = file("${rootProject.buildDir}/libs")
  }

  task sourcesJar(type: Jar, dependsOn: classes) {
    destinationDir = file("${rootProject.buildDir}/src")
    classifier = 'sources'
    from sourceSets.main.allSource
  }

  task dokkaJar(type: Jar, dependsOn: dokka) {
    destinationDir = file("${rootProject.buildDir}/docs")
    classifier = 'dokka'
    from dokka.outputDirectory
  }

  if (project.name != 'eth-reference-tests') {
    signing {
      useGpgCmd()
      sign configurations.archives
    }

    tasks.withType(Sign) {
      onlyIf { System.getenv('ENABLE_SIGNING') == 'true' }
    }

    artifacts {
      archives jar
      archives sourcesJar
      archives dokkaJar
    }

    publishing {
      publications {
        MavenDeployment(MavenPublication) { publication ->
          from components.java
          artifact sourcesJar { classifier 'sources' }
          artifact dokkaJar { classifier 'javadoc' }
          groupId 'net.consensys.cava'
          artifactId project.jar.baseName
          version project.version

          pom {
            name = project.jar.baseName
            description = project.description
            url = 'https://github.com/ConsenSys/cava'
            licenses {
              license {
                name = "The Apache License, Version 2.0"
                url = "http://www.apache.org/licenses/LICENSE-2.0.txt"
              }
            }
            scm {
              connection = 'scm:https://github.com/ConsenSys/cava.git'
              developerConnection = 'scm:git@github.com:ConsenSys/cava.git'
              url = 'https://github.com/ConsenSys/cava'
            }
            developers {
              developer {
                name = 'Chris Leishman'
                email = 'chris@leishman.org'
                organization = 'ConsenSys'
                organizationUrl = 'https://www.consensys.net'
              }
              developer {
                name = 'Antoine Toulme'
                email = 'antoine@lunar-ocean.com'
                organization = 'ConsenSys'
                organizationUrl = 'https://www.consensys.net'
              }
            }
          }
          pom.withXml {
            // restrict dependencyManagement dependencies to only those of the
            // current module
            def dm = asNode().dependencyManagement[0].dependencies[0]
            dm.value = dm.dependency.findAll { node ->
              def groupId = node.groupId[0].value()
              def artifactId = node.artifactId[0].value()
              configurations.compile.allDependencies.any { dep ->
                dep.group == groupId && dep.name == artifactId
              }
            }

            def dependenciesNode = asNode().appendNode('dependencies')
            configurations.compile.allDependencies.each {
              def dependencyNode = dependenciesNode.appendNode('dependency')
              dependencyNode.appendNode('groupId', it.group)
              dependencyNode.appendNode('artifactId', it.name)
            }
          }
        }
      }
    }

    def artifactIdMatcher = Pattern.compile("(.*)-\\d.*")
    bintray {
      user = System.getenv('BINTRAY_USER')
      key = System.getenv('BINTRAY_KEY')
      publications = ['MavenDeployment']
      filesSpec {
        project.extensions.getByType(PublishingExtension).publications.all { publication ->
          publication.getArtifacts().all {
            def ascFile = new File(it.file.getParentFile(), it.file.getName() + '.asc')
            if (ascFile.exists()) {
              def matcher = artifactIdMatcher.matcher(it.file.getName())
              matcher.find()
              def artifactId = matcher.group(1)
              from ascFile.getAbsolutePath()
              into publication.groupId.replaceAll('\\.', '/') + '/' + artifactId + '/' + publication.version + '/'
            }
          }
        }
      }
      dryRun = !(System.getenv('BINTRAY_DEPLOY') == 'true')
      publish = true
      pkg {
        repo = 'consensys'
        name = 'cava'
        userOrg = 'consensys'
        licenses = ['Apache-2.0']
        version {
          name = project.version
          desc = 'Cava distribution'
          released = new Date()
          vcsTag = project.version
        }
      }
    }
    deploy.dependsOn bintrayUpload
  }
}


subprojects {

  //////
  // Source formatting

  apply plugin: 'com.diffplug.gradle.spotless'
  spotless {
    java {
      target project.fileTree(project.projectDir) {
        include '**/*.java'
        exclude '**/generated-src/**/*.*'
      }
      removeUnusedImports()
      licenseHeaderFile rootProject.file('gradle/spotless.license.java')
      eclipse().configFile(rootProject.file('gradle/eclipse-java-consensys-style.xml'))
      importOrder 'net.consensys', 'java', ''
      endWithNewline()
    }
    kotlin {
      licenseHeaderFile rootProject.file('gradle/spotless.license.java')
      ktlint().userData(['indent_size': '2', 'continuation_indent_size' : '2', 'max_line_length': '120'])
      endWithNewline()
    }
  }


  //////
  // Parallel build execution

  tasks.withType(Test) {
    // If GRADLE_MAX_TEST_FORKS is not set, use half the available processors
    maxParallelForks = (System.getenv('GRADLE_MAX_TEST_FORKS') ?:
      (Runtime.runtime.availableProcessors().intdiv(2) ?: 1)).toInteger()
  }

  tasks.withType(JavaCompile) {
    options.fork = true
    options.incremental = true
  }

  task allDependencies(type: DependencyReportTask) {}
}

//////
// Bundle all subprojects

subprojects.each { evaluationDependsOn(it.path) }

jar {
  baseName = rootProject.name
  manifest {
    attributes('Implementation-Title': baseName,
    'Implementation-Version': project.version)
  }
  subprojects.each {
    from it.sourceSets.main.output
    dependsOn it.classes
  }
}

dependencies {
  subprojects.each {
    it.configurations.compile.allDependencies.each { d ->
      if (d instanceof ExternalModuleDependency) {
        add('compile', d)
      }
    }
    it.configurations.runtime.allDependencies.each { d ->
      if (d instanceof ExternalModuleDependency) {
        add('runtime', d)
      }
    }
  }
}

sourcesJar {
  baseName = rootProject.name
  manifest {
    attributes('Implementation-Title': baseName,
    'Implementation-Version': project.version)
  }
  subprojects.each {
    from it.sourceSets.main.allSource
    dependsOn it.classes
  }
}

javadoc {
  subprojects.each {
    source += it.javadoc.source
    classpath += it.javadoc.classpath
  }
}

dokka {
  moduleName = rootProject.name
  subprojects.each {
    dependsOn it.classes
    it.sourceSets.main.output.each { d ->
      if (d.exists()) {
        classpath += d
      }
    }
  }
  sourceDirs = files(subprojects.collect {
    return [
      new File(it.projectDir, '/src/main/kotlin'),
      new File(it.projectDir, '/src/main/java')
    ]
  })
  linkMapping {
    dir = rootDir.toString()
    url = "https://github.com/consensys/cava/blob/master"
    suffix = "#L"
  }

  includes = ['PACKAGES.md']

  externalDocumentationLink {
    url = new URL("https://docs.oracle.com/javase/8/docs/api/")
  }

  externalDocumentationLink {
    url = new URL('https://atoulme.github.io/kotlinx.coroutines/kotlinx-coroutines-core/')
  }
}

dokkaJar {
  baseName = rootProject.name
  manifest {
    attributes('Implementation-Title': baseName,
    'Implementation-Version': project.version)
  }
}

if (!file("${rootDir}/eth-reference-tests/src/test/resources/tests/README.md").exists()) {
  throw new GradleException("eth-reference-tests/src/test/resources/tests/README.md missing: please clone submodules (git submodule update --init --recursive)")
}
